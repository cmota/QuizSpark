
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Build an AI-Powered Quiz App with Gemini and Firebase</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="build-quiz-spark-gemini"
                  title="Build an AI-Powered Quiz App with Gemini and Firebase"
                  environment="web"
                  feedback-link="https://github.com/google/generative-ai-docs/issues">
    
      <google-codelab-step label="Overview" duration="1">
        <p>In this Codelab, you&#39;ll build <strong>Quiz Spark</strong>, a fully functional Android application that uses the Gemini API to generate quizzes on any topic a user enters. You&#39;ll also use Firebase Firestore to store and display a live leaderboard.</p>
<p class="image-container"><img alt="Design Mockups of Quiz Spark generated by Google&amp;rsquo;s Stitch project." src="img/1c510c76c0c0b3ac.png"></p>
<p>This Codelab is designed for those who have some basic experience with Android development but are new to generative AI with Gemini or backend services with Firebase. We&#39;ll explain every concept step-by-step.</p>
<h2 is-upgraded>What you&#39;ll build</h2>
<p>You&#39;ll build a complete Android app with three main screens:</p>
<ul>
<li><strong>Intro Screen</strong>: A screen where the user can enter any topic (e.g., &#34;Roman History,&#34; &#34;Kotlin Programming,&#34; &#34;Marine Biology&#34;).</li>
<li><strong>Quiz Screen</strong>: A screen that displays 10 multiple-choice questions about the chosen topic, generated in real-time by the Gemini API.</li>
<li><strong>Leaderboard Screen</strong>: A screen that shows the highest scores, saved to and read from a live Firebase Firestore database.</li>
</ul>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<ul class="checklist">
<li>How to integrate the <strong>Firebase AI SDK for Gemini</strong> into an Android app.</li>
<li>How to use <strong>system instructions</strong> and JSON mode to get structured, reliable output from the Gemini API.</li>
<li>How to use <strong>Firebase Firestore</strong> to save and retrieve data in real-time.</li>
<li>How to structure a modern Android app using <strong>Jetpack Compose, ViewModels, and UiState.</strong></li>
<li>How to build a clean, multi-screen navigation flow in Compose.</li>
</ul>
<h2 is-upgraded>What you&#39;ll need</h2>
<ul>
<li>The latest version of <a href="https://developer.android.com/studio" target="_blank">Android Studio</a>.</li>
<li>A <a href="https://firebase.google.com/docs/android/setup" target="_blank">Firebase project</a>.</li>
<li>Basic knowledge of the Kotlin programming language.</li>
<li>An Android device or emulator.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setup Your Firebase Project" duration="10">
        <p>Before we start coding, we need to set up our Firebase backend. Quiz Spark uses two Firebase services:</p>
<ul>
<li><strong>Firebase AI Logic (Gemini)</strong>: To generate the quiz questions.</li>
<li><strong>Cloud Firestore:</strong> To save and load the leaderboard scores.</li>
</ul>
<h2 is-upgraded>Create a Firebase Project</h2>
<ol type="1">
<li>Go to the <a href="https://console.firebase.google.com/" target="_blank">Firebase console</a>.</li>
<li>Click <strong>Create a new Firebase project</strong> and follow the on-screen instructions to create a new project. Give it a name like &#34;Quiz Spark&#34;.</li>
</ol>
<h2 is-upgraded>Add Firebase to your Android App</h2>
<p>In your new project&#39;s <strong>Project Overview</strong>, click on <strong>+ Add app</strong> and then select the <strong>Android</strong> icon to launch the setup wizard.</p>
<p>Enter your application&#39;s package name. You can find this in your <code>app/build.gradle.kts</code> file (it&#39;s <code>com.cmota.quizspark</code> for this project).</p>
<p>Download the <code>google-services.json</code> file and place it in your app&#39;s module (app-level) directory (usually <code>app/</code>).</p>
<p>Follow the wizard&#39;s instructions to add the Firebase SDKs (Bill of Materials) to your <code>build.gradle.kts</code> files.</p>
<h2 is-upgraded>Enable Required Services</h2>
<h3 is-upgraded>Enable Firebase AI Logic</h3>
<ol type="1">
<li>In the Firebase console, navigate to <strong>AI</strong> in the left-hand menu.</li>
<li>Click <strong>Get started</strong>.</li>
<li>Select <strong>Get started with this API</strong> under the <strong>Gemini Developer API</strong> card.</li>
<li>Follow the prompts on the screen to enable this API.</li>
</ol>
<h3 is-upgraded>Enable Cloud Firestore</h3>
<ol type="1">
<li>In the Firebase console, go to <strong>Build &gt; Firestore Database</strong>.</li>
<li>Click <strong>Create database</strong>.</li>
<li>Start in <strong>Test mode</strong>. This allows us to read and write to the database without complex authentication rules. For a production app, you would set up more secure rules.</li>
<li>Choose a location for your Firestore data.</li>
</ol>
<h2 is-upgraded>Add Dependencies</h2>
<p>Open your <code>app/build.gradle.kts</code> file and ensure you have the following dependencies added. These are the key libraries for our project.</p>
<pre><code language="language-Kotlin" class="language-Kotlin">// Firebase Bill of Materials (BoM)
implementation(platform(&#34;com.google.firebase:firebase-bom:33.1.1&#34;))

// Firebase AI (for Gemini)
implementation(&#34;com.google.firebase:firebase-ai&#34;)

// Firebase Firestore (for Leaderboard)
implementation(&#34;com.google.firebase:firebase-firestore&#34;)

// Kotlinx Serialization for parsing JSON from Gemini
implementation(&#34;org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.0&#34;)
</code></pre>
<p>With our backend ready, let&#39;s start building the app!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 1: Define the Data Models" duration="5">
        <p>A good app starts with a clear data structure. We have two main data models: <code>Question</code> and <code>User</code>.</p>
<h2 is-upgraded>Question Model</h2>
<p>This defines the structure for a single quiz question. We&#39;ll tell the Gemini API to provide its response in this exact format. The <code>@Serializable</code> annotation is from the Kotlinx Serialization library, which will help us parse the JSON response from Gemini easily.</p>
<p>Create the file <code>java/com/cmota/quizspark/model/Question.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.model

import kotlinx.serialization.Serializable

@Serializable
data class Question(
  val question: String = &#34;&#34;,
  val options: List&lt;String&gt; = emptyList(),
  val correct: Int = 0
)
</code></pre>
<h2 is-upgraded>User Model</h2>
<p>This defines the data we&#39;ll store in our Firestore leaderboard for each user. <code>@DocumentId</code> tells Firestore to automatically populate the uid field with the document&#39;s unique ID.</p>
<p>Create the file <code>java/com/cmota/quizspark/model/User.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.model

import com.google.firebase.firestore.DocumentId

data class User(
  @DocumentId val uid: String? = null,
  val username: String = &#34;&#34;,
  val score: Long = 0L
)
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Step 2: Set Up App Theme and Navigation" duration="10">
        <p>Before building screens, let&#39;s set up our app&#39;s visual style (Theme) and how we move between screens (Navigation).</p>
<h2 is-upgraded>Theme</h2>
<p>Our theme files define the app&#39;s look and feel, including colors and typography. This project uses a dark, &#34;spark&#34; theme.</p>
<ul>
<li><code>java/com/cmota/quizspark/ui/theme/Color.kt</code><br> Defines our custom colors like <code>darkGreenBackground</code> and <code>brightGreen</code>.</li>
<li><code>java/com.cmota/quizspark/ui/theme/Type.kt</code><br> Sets up the font styles.</li>
<li><code>java/com/cmota/quizspark/ui/theme/Theme.kt</code><br> Brings it all together in a <code>QuizSparkTheme</code> composable, which wraps our entire application.</li>
</ul>
<h2 is-upgraded>Navigation</h2>
<p>We use navigation library 3.</p>
<ul>
<li><strong>Navigation Routes</strong>: First, we define our screens (routes) as serializable objects. This is a clean, type-safe way to manage navigation.</li>
</ul>
<p>Create <code>java/com/cmota/quizspark/ui/navigation/NavigationRoutes.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.ui.navigation

import androidx.navigation3.runtime.NavKey
import kotlinx.serialization.Serializable

@Serializable
data object Intro: NavKey

@Serializable
data object Quiz: NavKey

@Serializable
data object Leaderboard: NavKey
</code></pre>
<ul>
<li><strong>Main Navigation Graph</strong>: This file, <code>MainNavigation.kt</code>, is the app&#39;s &#34;scaffolding.&#34; It defines which screen is shown and how to transition between them. It also initializes and passes our <code>ViewModels</code> to the correct screens.</li>
</ul>
<p>Create <code>java/com/cmota/quizspark/ui/navigation/MainNavigation.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.ui.navigation

import androidx.compose.runtime.Composable
import androidx.navigation3.runtime.entryProvider
import androidx.navigation3.runtime.rememberNavBackStack
import androidx.navigation3.ui.NavDisplay
import com.cmota.quizspark.ui.leaderboard.LeaderboardViewModel
import com.cmota.quizspark.ui.questions.QuestionsViewModel
import com.cmota.quizspark.ui.screens.IntroScreen
import com.cmota.quizspark.ui.screens.LeaderboardScreen
import com.cmota.quizspark.ui.screens.QuizScreen

@Composable
fun MainNavigation(
  questionsViewModel: QuestionsViewModel,
  leaderboardViewModel: LeaderboardViewModel
) {
  // Start the app with the Intro screen
  val backStack = rememberNavBackStack(Intro)

  NavDisplay(
    backStack = backStack,
    onBack = { backStack.removeLastOrNull() },
    entryProvider = entryProvider {
      
      entry&lt;Intro&gt; {
        IntroScreen(
          navigateToQuiz = { topic -&gt;
            backStack.add(Quiz)
            questionsViewModel.generateQuiz(topic)
          }
        )
      }

      entry&lt;Quiz&gt; {
        QuizScreen(
          questionsViewModel = questionsViewModel,
          leaderboardViewModel = leaderboardViewModel,
          navigateToHome = { backStack.remove(Quiz) },
          navigateToLeaderboard = { backStack.add(Leaderboard) }
        )
      }

      entry&lt;Leaderboard&gt; {
        leaderboardViewModel.fetchLeaderboard()

        LeaderboardScreen(
          leaderboardViewModel = leaderboardViewModel,
          navigateToHome = {
            backStack.remove(Leaderboard)
            backStack.remove(Quiz)
          }
        )
      }
    }
  )
}
</code></pre>
<ol type="1" start="3">
<li><strong>Main Activity</strong>: Finally, <code>MainActivity.kt</code> is the app&#39;s entry point. It sets up our <code>QuizSparkTheme</code> and calls <code>MainNavigation</code>, injecting our ViewModels.</li>
</ol>
<p>From <code>java/com/cmota/quizspark/MainActivity.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark

// ... imports
import androidx.activity.viewModels
import com.cmota.quizspark.ui.leaderboard.LeaderboardViewModel
import com.cmota.quizspark.ui.navigation.MainNavigation
import com.cmota.quizspark.ui.questions.QuestionsViewModel
import com.cmota.quizspark.ui.theme.QuizSparkTheme

class MainActivity : ComponentActivity() {

  private val questionsViewModel: QuestionsViewModel by viewModels()
  private val leaderboardViewModel: LeaderboardViewModel by viewModels()

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    enableEdgeToEdge()
    setContent {
      QuizSparkTheme {
        MainNavigation(
          questionsViewModel = questionsViewModel,
          leaderboardViewModel = leaderboardViewModel
        )
      }
    }
  }
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Step 3: Build the Intro Screen" duration="5">
        <p>This is our simplest screen. It&#39;s composed of a text field and a button.</p>
<p>Create <code>java/com/cmota/quizspark/ui/screens/IntroScreen.kt</code>.</p>
<p>The UI is built with standard Jetpack Compose composables like <code>Column</code>, <code>Text</code>, <code>OutlinedTextField</code>, and <code>Button</code>.</p>
<p>The two most important parts are:</p>
<ul>
<li><strong>State Management</strong>: We use <code>remember { mutableStateOf("") }</code> to hold the text the user types into the text field.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">val topic = remember { mutableStateOf(&#34;&#34;) }

OutlinedTextField(
  value = topic.value,
  onValueChange = { topic.value = it },
  // ...
)
</code></pre>
<ul>
<li><strong>Navigation</strong>: When the user clicks the &#34;Start&#34; button, we call the <code>MapsToQuiz</code> lambda function that was passed in from <code>MainNavigation</code>. This triggers the navigation to the <code>QuizScreen</code>. We also pass the <code>topic.value</code> (the text from the text field) to it.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">Button(
  onClick = { navigateToQuiz(topic.value) },
  // ...
  enabled = topic.value.isNotEmpty()
) {
  Text(
    text = stringResource(R.string.intro_start),
    // ...
  )
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Step 4: Generate Quizzes with Gemini" duration="15">
        <p>This is the heart of the application. We&#39;ll use a ViewModel to handle the logic of calling the Gemini API and parsing its response.</p>
<h2 is-upgraded>UI State</h2>
<p>First, we need a way to represent the different states of our quiz screen: Is it loading? Did it succeed? Did it fail? A sealed interface is perfect for this.</p>
<p>Create <code>java/com/cmota/quizspark/ui/questions/UiState.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.ui.questions

import com.cmota.quizspark.model.Question

sealed interface UiState {
  data object Initial : UiState
  data object Loading : UiState
  data class Success(val questions: List&lt;Question&gt;) : UiState
  data class Error(val message: String) : UiState
}
</code></pre>
<h2 is-upgraded>Questions ViewModel</h2>
<p>This is where the magic happens. This class is responsible for all the logic related to the quiz.</p>
<p>Create <code>java/com/cmota/quizspark/ui/questions/QuestionsViewModel.kt</code>.</p>
<p>Let&#39;s break it down.</p>
<h3 is-upgraded>System Instruction</h3>
<p>This is a <em>critical</em> concept. We give the Gemini API a &#34;system instruction&#34; that tells it how to behave. We instruct it to be a quiz assistant and, most importantly, to only respond with a valid JSON array matching our `Question data model.</p>
<pre><code language="language-Kotlin" class="language-Kotlin">private const val QUESTIONS = 10

// ...

private val systemInstruction = &#34;&#34;&#34;
    You are a quiz generation assistant.
    Your response MUST be a single, valid JSON array.
    The array must contain exactly $QUESTIONS JSON objects.
    Do not add any other text, explanation, or markdown formatting around the JSON.

    Each JSON object in the array must match this exact structure:
    {
      &#34;question&#34;: &#34;The question text as a string.&#34;,
      &#34;options&#34;: &#34;A list of 4 strings for the answers.&#34;,
      &#34;correct&#34;: &#34;The 0-based index (integer) of the correct answer.&#34;
    }
    &#34;&#34;&#34;
</code></pre>
<h3 is-upgraded>Model Initialization</h3>
<p>Here, we initialize the <code>generativeModel</code>.</p>
<ul>
<li>We use <code>Firebase.ai(backend = GenerativeBackend.googleAI())</code> to get the service.</li>
<li>We pass in our <code>systemInstruction</code>.</li>
<li>We set <code>responseMimeType = "application/json"</code>. This, combined with our system instruction, enables <strong>JSON mode</strong>, ensuring the API&#39;s output is only the JSON we asked for.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">private val generationConfig = generationConfig {
    responseMimeType = &#34;application/json&#34;
}

private val generativeModel by lazy {
    Firebase.ai(backend = GenerativeBackend.googleAI())
      .generativeModel(
        modelName = &#34;gemini-2.5-flash-lite&#34;,
        generationConfig = generationConfig,
        systemInstruction = content {
          text(systemInstruction)
        }
      )
}


private val jsonParser = Json { ignoreUnknownKeys = true }
</code></pre>
<h2 is-upgraded>Generating the Quiz</h2>
<p>The <code>generateQuiz</code> function is called from our <code>MainNavigation</code> when the user clicks &#34;Start&#34;.</p>
<ul>
<li>It sets the state to <code>Loading</code>.</li>
<li>It creates a simple prompt, like &#34;Generate 10 questions about Roman History.&#34;</li>
<li>It calls <code>generativeModel.generateContent(prompt)</code>.</li>
<li>Because we set up JSON mode, the <code>response.text</code> will be a clean JSON string.</li>
<li>We use <code>jsonParser.decodeFromString</code> to turn that string into a <code>List<Question></code>.</li>
<li>We update the state to <code>Success</code>, passing in the list of questions.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">fun generateQuiz(topic: String) {
    viewModelScope.launch {
      try {
        answered.clear()
        _questions.value = UiState.Loading

        val prompt = &#34;Generate $QUESTIONS question about $topic.&#34;

        val response = generativeModel.generateContent(prompt)
        val questions = jsonParser.decodeFromString&lt;List&lt;Question&gt;&gt;(response.text ?: &#34;&#34;)

        _question.value = questions.first()
        _questions.value = UiState.Success(questions)

        _indexLast.value = questions.size
        _indexCurrent.value = 1

      } catch (e: Exception) {
        Log.d(TAG, &#34;Error: ${e.message}&#34;)
        _questions.value = UiState.Error(e.message ?: &#34;An unknown error occurred&#34;)
      }
    }
}
</code></pre>
<h3 is-upgraded>Helper Functions</h3>
<p>The <code>answerQuestion</code> and <code>score</code> functions handle the quiz logic, like moving to the next question and counting the correct answers at the end.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 5: Build the Quiz Screen" duration="10">
        <p>Now that our <code>QuestionsViewModel</code> can generate quizzes, let&#39;s build the UI to display them.</p>
<p>Create <code>java/com/cmota/quizspark/ui/screens/QuizScreen.kt</code>.</p>
<p>This screen observes the state from the <code>QuestionsViewModel</code>.</p>
<h3 is-upgraded>Collecting State</h3>
<p>We collect the <code>UiState</code> from the ViewModel. Compose will automatically &#34;recompose&#34; (re-draw) the UI whenever this state changes.</p>
<pre><code language="language-Kotlin" class="language-Kotlin">@Composable
fun QuizScreen(
  // ...
) {
  val question = questionsViewModel.question.collectAsState()
  val questions = questionsViewModel.questions.collectAsState()
  // ...
  val selectedOption = remember { mutableStateOf&lt;Int?&gt;(null) }
  
  // ...
  
    QuizContent(
      modifier = Modifier.padding(innerPadding),
      question = question.value,
      questions = questions.value,
      selectedOption = selectedOption
    )
  // ...
}
</code></pre>
<h3 is-upgraded>Handling States</h3>
<p>The <code>QuizContent</code> composable uses a <code>when</code> block to decide what to show based on the <code>UiState</code>:</p>
<ul>
<li><code>Initial</code> / <code>Loading</code>: Show a <code>QuizContentLoading</code> composable (a progress bar).</li>
<li><code>Success</code>: Show the <code>QuizContentSuccess</code> composable with the actual question.</li>
<li><code>Error</code>: Show a <code>QuizContentError</code> message.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">@Composable
private fun QuizContent(
  modifier: Modifier,
  question: Question,
  questions: UiState, // The UiState
  selectedOption: MutableState&lt;Int?&gt;
) {
  Column(
    // ...
  ) {
    when(questions) {
      is UiState.Initial,
      is UiState.Loading -&gt; QuizContentLoading()
      is UiState.Success -&gt; QuizContentSuccess(
          question = question,
          selectedOption = selectedOption
      )
      is UiState.Error -&gt; QuizContentError()
    }
  }
}
</code></pre>
<h3 is-upgraded>Displaying the Question</h3>
<p>The <code>QuizContentSuccess</code> composable displays the question text and loops through the <code>question.options</code>, creating a <code>QuizOption</code> row for each one.</p>
<h3 is-upgraded>Submitting Score</h3>
<p>When the user finishes the last question, the &#34;Next&#34; button becomes a &#34;Submit&#34; button. This shows an <code>AlertDialog</code> (<code>UsernameDialog</code>) asking for their name before saving the score.</p>
<p>This logic is all in the <code>Scaffold</code>&#39;s <code>bottomBar</code>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 6: Save Scores to Firestore" duration="10">
        <p>When the user submits their score, we need to save it to our Firebase Firestore database. This logic lives in the <code>LeaderboardViewModel</code>.</p>
<h3 is-upgraded>Leaderboard UI State</h3>
<p>Just like with the quiz, we create a <code>UiState</code> for our leaderboard.</p>
<p>Create <code>java/com/cmota/quizspark/ui/leaderboard/UiState.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.ui.leaderboard

import com.cmota.quizspark.model.User

sealed interface UiState {
  data object Initial : UiState
  data object Loading : UiState
  data class Success(val users: List&lt;User&gt;) : UiState
  data class Error(val message: String) : UiState
}
</code></pre>
<h3 is-upgraded>Leaderboard ViewModel</h3>
<p>Create <code>java/com/cmota/quizspark/ui/leaderboard/LeaderboardViewModel.kt</code>.</p>
<p>This ViewModel has two main jobs: saving points and fetching the leaderboard.</p>
<ol type="1">
<li><strong>Saving Points</strong>: The <code>savePoints</code> function is called from <code>QuizScreen</code> when the user submits their name from the dialog.</li>
</ol>
<ul>
<li>It calculates the score.</li>
<li>It creates a <code>mapOf</code> entry that matches our <code>User</code> model (username, score, and a server timestamp).</li>
<li>It uses <code>Firebase.firestore.collection("leaderboard").add(entry)</code> to add a new document to our &#34;leaderboard&#34; collection. Firestore handles the rest.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">fun savePoints(username: String, correct: Int) {
    val score = correct * 10
    val db = Firebase.firestore
    val entry = mapOf(
      &#34;username&#34; to username,
      &#34;score&#34; to score,
      &#34;timestamp&#34; to FieldValue.serverTimestamp()
    )

    db.collection(&#34;leaderboard&#34;).add(entry)
}
</code></pre>
<ol type="1" start="2">
<li><strong>Fetching Leaderboard</strong>: The fetchLeaderboard function is called from <code>MainNavigation</code> just before the <code>LeaderboardScreen</code> is displayed.</li>
</ol>
<ul>
<li>It sets the state to <code>Loading</code>.</li>
<li>It creates a query to get the &#34;leaderboard&#34; collection.</li>
<li>It orders the results by &#34;score&#34; in descending order (highest score first).</li>
<li>It calls <code>.get().await()</code> to fetch the data.</li>
<li>It uses the handy <code>.toObjects(User::class.java)</code> function to automatically convert the Firestore documents into our <code>User</code> data class.</li>
<li>It updates the state to <code>Success</code> with the list of users.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">fun fetchLeaderboard() {
    viewModelScope.launch {
      _leaderboard.value = UiState.Loading

      try {
        val query = Firebase.firestore
          .collection(&#34;leaderboard&#34;)
          .orderBy(&#34;score&#34;, Query.Direction.DESCENDING)

        val snapshot = query.get().await()

        val leaderboardList = snapshot.toObjects(User::class.java)

        _leaderboard.value = UiState.Success(leaderboardList)

      } catch (e: Exception) {
        Log.d(TAG, &#34;Error: ${e.message}&#34;)
        _leaderboard.value = UiState.Error(e.message ?: &#34;Unknown error&#34;)
      }
    }
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Step 7: Build the Leaderboard Screen" duration="5">
        <p>This is our final screen. It&#39;s very similar to the QuizScreen in that it just observes the <code>UiState</code> from its ViewModel.</p>
<p>Create <code>java/com/cmota/quizspark/ui/screens/LeaderboardScreen.kt</code>.</p>
<p>Like the quiz screen, it collects the <code>UiState</code> from the <code>LeaderboardViewModel</code> and uses a <code>when</code> block to display the correct content.</p>
<pre><code language="language-Kotlin" class="language-Kotlin">@Composable
fun LeaderboardScreen(
  leaderboardViewModel: LeaderboardViewModel,
  navigateToHome: () -&gt; Unit
) {
  // 1. Collect the state
  val leaderboard = leaderboardViewModel.leaderboard.collectAsState()

  Scaffold(...) { innerPadding -&gt;
    LeaderboardContent(
      modifier = Modifier.padding(innerPadding),
      // 2. Pass the state to the content
      leaderboard = leaderboard.value
    )
  }
}

@Composable
private fun LeaderboardContent(
  modifier: Modifier,
  leaderboard: UiState
) {
  Column(...) {
    // 3. Use a &#39;when&#39; block to display the right UI
    when (leaderboard) {
      is UiState.Initial,
      is UiState.Loading -&gt; LeaderboardLoading()
      is UiState.Success -&gt; LeaderboardSuccess(leaderboard.users)
      is UiState.Error -&gt; LeaderboardError()
    }
  }
}
</code></pre>
<p>The <code>LeaderboardSuccess</code> function simply uses a <code>LazyColumn</code> (a vertically scrolling list) to display a <code>LeaderboardUser</code> row for each user in the list.</p>
<p>Congratulations!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Congratulations!" duration="1">
        <p>You&#39;ve successfully built a complete AI-powered Android application!</p>
<p>You learned how to:</p>
<ul>
<li>Use the Gemini API with system instructions and <strong>JSON mode</strong> to generate structured data.</li>
<li>Integrate the <strong>Firebase AI</strong> and <strong>Firestore</strong> SDKs into an Android app.</li>
<li>Save and retrieve real-time data from <strong>Cloud Firestore</strong>.</li>
<li>Structure a modern app using <strong>Jetpack Compose</strong>, <strong>ViewModels</strong>, and a <strong>UiState</strong> pattern.</li>
<li>You can expand this project by adding user authentication, storing quizzes, or using more of the Gemini API&#39;s capabilities.</li>
</ul>
<h2 is-upgraded>Further Reading</h2>
<ul>
<li><a href="https://firebase.google.com/docs/vertex-ai" target="_blank">Firebase AI Logic Documentation</a></li>
<li><a href="https://firebase.google.com/docs/firestore" target="_blank">Cloud Firestore Documentation</a></li>
<li><a href="https://developer.android.com/jetpack/compose/navigation" target="_blank">Jetpack Compose Navigation</a></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
